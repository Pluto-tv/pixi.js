{"version":3,"sources":["../../../src/core/text/TextMetrics.js"],"names":["TextMetrics","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","wordWrap","canvas","_canvas","font","toFontString","measureFont","context","getContext","outputText","split","Array","length","i","lineWidth","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","fontSize","leading","result","linesEncountered","continueMark","continueMarkWidth","spaceLeft","wordWrapWidth","characterCache","maxLines","words","j","wordWidth","breakWords","characters","c","character","characterWidth","undefined","wordWidthWithSpace","_fonts","properties","_context","ceil","baseline","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","line","idx","stop","ascent","descent","document","createElement"],"mappings":"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","file":"TextMetrics.js","sourcesContent":["/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n *\n * @class\n * @memberOf PIXI\n */\nexport default class TextMetrics\n{\n    /**\n     * @param {string} text - the text that was measured\n     * @param {PIXI.TextStyle} style - the style that was measured\n     * @param {number} width - the measured width of the text\n     * @param {number} height - the measured height of the text\n     * @param {array} lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param {array} lineWidths - an array of the line widths for each line matched to `lines`\n     * @param {number} lineHeight - the measured line height for this style\n     * @param {number} maxLineWidth - the maximum line width for all measured lines\n     * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     *\n     * @param {string} text - the text to measure.\n     * @param {PIXI.TextStyle} style - the text style to use for measuring\n     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.\n     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n     * @return {PIXI.TextMetrics} measured width and height of the text.\n     */\n    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas)\n    {\n        wordWrap = wordWrap || style.wordWrap;\n        const font = style.toFontString();\n        const fontProperties = TextMetrics.measureFont(font);\n        const context = canvas.getContext('2d');\n        \n        context.font = font;\n\n        const outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        let width = maxLineWidth + style.strokeThickness;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadowDistance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n        let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadowDistance;\n        }\n\n        return new TextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     *\n     * @private\n     * @param {string} text - String to apply word wrapping to\n     * @param {PIXI.TextStyle} style - the style to use when wrapping\n     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n     * @return {string} New string with new lines applied where required\n     */\n    static wordWrap(text, style, canvas = TextMetrics._canvas)\n    {\n        const context = canvas.getContext('2d');\n\n        // Greedy wrapping algorithm that will wrap words as the line grows longer\n        // than its horizontal bounds.\n        let result = '';\n        let linesEncountered = 0;\n        let continueMark = '';\n        let continueMarkWidth = 0;\n        let spaceLeft = 0;\n\n        const lines = text.split('\\n');\n        const wordWrapWidth = style.wordWrapWidth;\n        const characterCache = {};\n\n        for (let i = 0; i < lines.length && (style.maxLines <= 0 || linesEncountered < style.maxLines); i++)\n        {\n            spaceLeft = wordWrapWidth - continueMarkWidth;\n            continueMark = style.maxLines <= 0 || linesEncountered !== style.maxLines - 1 ? '' : typeof style.continueMark === 'boolean' ? (style.continueMark ? '...' : '') : style.continueMark;\n            continueMarkWidth = continueMark && continueMark.length > 0 ? context.measureText(continueMark).width : 0;\n            \n            const words = lines[i].split(' ');\n\n            for (let j = 0; j < words.length && (style.maxLines <= 0 || linesEncountered < style.maxLines); j++)\n            {\n                const wordWidth = context.measureText(words[j]).width;\n\n                if (style.breakWords && wordWidth > spaceLeft)\n                {\n                    // Word should be split in the middle\n                    const characters = words[j].split('');\n                    \n                    for (let c = 0; c < characters.length; c++)\n                    {\n                        const character = characters[c];\n                        let characterWidth = characterCache[character];\n\n                        if (characterWidth === undefined)\n                        {\n                            characterWidth = context.measureText(character).width;\n                            characterCache[character] = characterWidth;\n                        }\n\n                        if (characterWidth > spaceLeft)\n                        {\n                            if (style.maxLines > 0 && ++linesEncountered >= style.maxLines) {\n                                if (continueMark && continueMark.length > 0) \n                                {\n                                    result += continueMark\n                                }\n\n                                break;\n                            }\n                            \n                            continueMark = style.maxLines <= 0 || linesEncountered !== style.maxLines - 1 ? '' : typeof style.continueMark === 'boolean' ? (style.continueMark ? '...' : '') : style.continueMark;\n                            continueMarkWidth = continueMark && continueMark.length > 0 ? context.measureText(continueMark).width : 0;\n                            \n                            result += `\\n${character}`;\n                            spaceLeft = wordWrapWidth - characterWidth - continueMarkWidth;\n                        }\n                        else\n                        {\n                            if (c === 0)\n                            {\n                                result += ' ';\n                            }\n\n                            result += character;\n                            spaceLeft -= characterWidth;\n                        }\n                    }\n                }\n                else\n                {\n                    const wordWidthWithSpace = wordWidth + context.measureText(' ').width;\n\n                    if (j === 0 || wordWidthWithSpace > spaceLeft)\n                    {\n                        // Skip printing the newline if it's the first word of the line that is\n                        // greater than the word wrap width.\n                        if (j > 0)\n                        {\n                            if (style.maxLines > 0 && ++linesEncountered >= style.maxLines) {\n                                break;\n                            }\n\n                            result += '\\n';\n                        }\n\n                        result += words[j];\n                        spaceLeft = wordWrapWidth - wordWidth;\n                    }\n                    else\n                    {\n                        spaceLeft -= wordWidthWithSpace;\n                        result += ` ${words[j]}`;\n                    }\n                }\n            }\n\n            if (i < lines.length - 1)\n            {\n                result += '\\n';\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     *\n     * @static\n     * @param {string} font - String representing the style of the font\n     * @return {PIXI.TextMetrics~FontMetrics} Font properties object\n     */\n    static measureFont(font)\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (TextMetrics._fonts[font])\n        {\n            return TextMetrics._fonts[font];\n        }\n\n        const properties = {};\n\n        const canvas = TextMetrics._canvas;\n        const context = TextMetrics._context;\n\n        context.font = font;\n\n        const width = Math.ceil(context.measureText('|MÉq').width);\n        let baseline = Math.ceil(context.measureText('M').width);\n        const height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = font;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        const imagedata = context.getImageData(0, 0, width, height).data;\n        const pixels = imagedata.length;\n        const line = width * 4;\n\n        let i = 0;\n        let idx = 0;\n        let stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; ++i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; --i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        TextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n}\n\n/**\n * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.\n * @class FontMetrics\n * @memberof PIXI.TextMetrics~\n * @property {number} ascent - The ascent distance\n * @property {number} descent - The descent distance\n * @property {number} fontSize - Font size from ascent to descent\n */\n\nconst canvas = document.createElement('canvas');\n\ncanvas.width = canvas.height = 10;\n\n/**\n * Cached canvas element for measuring text\n * @memberof PIXI.TextMetrics\n * @type {HTMLCanvasElement}\n * @private\n */\nTextMetrics._canvas = canvas;\n\n/**\n * Cache for context to use.\n * @memberof PIXI.TextMetrics\n * @type {CanvasRenderingContext2D}\n * @private\n */\nTextMetrics._context = canvas.getContext('2d');\n\n/**\n * Cache of PIXI.TextMetrics~FontMetrics objects.\n * @memberof PIXI.TextMetrics\n * @type {Object}\n * @private\n */\nTextMetrics._fonts = {};\n"]}